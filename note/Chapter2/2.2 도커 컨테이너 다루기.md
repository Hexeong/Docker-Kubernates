>💡 도커 엔진을 설치하고 컨테이너와 이미지의 기본적인 개념을 이해했다면 도커 엔진을 사용할 준비가 끝났습니다. 이번에는 도커 컨테이너의 기초적인 사용법을 알아봅시다.

# 2.2.1 컨테이너 생성

```docker
docker -v
# docker 버젼 확인 명령어

docker pull centos7
# 도커 허브에서 공식 이미지를 다운로드 받는 명령어

docker run -i -t ubuntu:14.04
# docker 공식 이미지 중 우분투 이미지로 컨테이너를 실행
# 실행하면서 i로 표준입력 옵션과 t로 가상 터미널 옵션을 추가
# 만약 현재 우분투 이미지가 없다면 도커 허브에서 다운로드 받음

docker images
# 이미지 리스트 출력하는 명령어

docker create -i -t --name mycentos centos:7
# centos:7이라는 이미지로 mycentos라는 이름의 컨테이너를 생성하는 명령어

docker start mycentos
# mycentos라는 컨테이너를 실행시키는 명령어
# 여러 개의 컨테이너를 한번에 실행시킬 수 있다. 이는 stop과 restart에도
# 해당된다

docker attach mycentos
# mycentos라는 컨테이너 내부로 들어가는 명령어
```

# 2.2.2 컨테이너 목록 확인

```docker
docker ps
# 살아있는 컨테이너 목록을 확인하는 명령어

docker ps -a
# 죽어있는 모든 컨테이너까지 포함한 목록을 확인하는 명령어

docker inspect mycentos
# mycentos 컨테이너의 정보를 출력하는 명령어

docker inspect mycentos | grep Id
# 컨테이너의 Id를 확인하는 명령어
# Windows 환경에서는 `docker inspect mycentos | findstr "Id"` 명령어로 대체
```

# 2.2.3 컨테이너 삭제

```docker
docker rm mycentos
# mycentos라는 컨테이너를 삭제하는 명령어

docker stop mycentos
# mycentos라는 컨테이너를 삭제하기 위해서 실행중인 컨테이너를 중지시키는 명령어

docker rm -f mycentos
# 해당 컨테이너를 강제 삭제하는 명령어, 실행중이여도 삭제 됨.

docker container prune
# 모든 컨테이너를 삭제하는 명령어

docker stop $(docker ps -a -q)
docker rm $(docker ps -a -q)
# docker ps -a -q로 모든 컨테이너의 Id만을 조회한 다음 해당 Id를 가진 컨테이너들을 
# 전부 중지/삭제하는 명령어, 해당 명령어는 Linux기반으로 Windows에서는 $를 뺴야 함.
```

# 2.2.4 컨테이너를 외부에 노출

```docker
docker run -i -t --name network_test ubuntu:14.04
# ifconfig으로 우분투 환경에서 네트워크 환경을 조회할 수 있는 명령어
# 해당 명령어로 본 네트워크 환경은 도커의 NAT IP인 127.17.0.2를 할당받은 
# eth0 인터페이스와 로컬 호스트인 lo 인터페이스가 나타난다.
# 해당 인터페이스들의 IP끼리 포트 바인딩이 되어야 외부와 통신이 가능함

docker run -i -t --name mywebserver -p 80:80 ubuntu:14.04
# 해당 명령어로 mywebserver에 대해 호스트/컨테이너의 포트바인딩 설정이 가능하다. 
# 외부:내부는 80:80이다.

docker run -i -t -p 127.0.0.1:15530:80 ubuntu:14.04
# 해당 명령어처럼 IP 또한 지정해서 포트 바인딩이 가능하다
# apt-get update, apt-get install apache2 -y, service apache2 start 명령어로
# 아파치 서버를 시작해서 연결이 잘 되는지 확인해볼 수 있다.
# 만약 아파치 서버가 켜지면서 AH00558 경고 문구가 뜨는 건 도커 컨테이너 내부에서는
# IP 주소만 할당된 상태로 실행되기에 localhost라는 도메인 네임이 없어 발생하는 경고
# 문구로 무시하면 된다.

docker run -p 80:80 -p 443:443 <이미지>
# 해당 명령어처럼 -p를 여러 번 입력하여 여러 개의 포트 바인딩이 가능하다.
```

# 2.2.5 컨테이너 애프리케이션 구축

```docker
docker run -d \\
--name wordpressdb \\
-e MYSQL_ROOT_PASSWORD=password \\
-e MYSQL_DATABASE=wordpress \\
mysql:8
# mysql DB 컨테이너 생성 명령어, 환경 변수는 -e 옵션으로 넘겨줌
# windows 환경에서는 \\ 대신 `을 사용

docker run -d \\
--name wordpress \\
-e WORDPRESS_DB_HOST=mysql \\
-e WORDPRESS_DB_USER=root \\
-e WORDPRESS_DB_PASSWORD=password \\
--link wordpressdb:mysql \\
-p 15530:80 \\
wordpress
# 워드프레스 웹 서버 컨테이너를 실행하는 명령어
# windows 환경에서는 \\ 대신 `을 사용

# --link 옵션은 A 컨테이너에서 B 컨테이너로 접근하는 방법 중 가장 간단한
# 것으로 NAT로 할당 받은 내부 IP를 사용하는 것이다. 그러나 도커 엔진은
# 컨테이너 내부 IP를 순차적으로 할당하기에 매번 변경되는 컨테이너의 IP로
# 접근하기 어려운 문제가 있다. 따라서 --link 옵션은 항상 컨테이너에 별명
# 으로 접근하도록 설정한다. 위에서 생성한 워드 프레스 웹 서버 컨테이너는
# wordpressdb 컨테이너를 mysql이라는 별명을 붙여 접근하도록 했다
# 실제 wordpress 컨테이너에서 curl mysql:3306 입력하면 접근이 된다.

# 또한 --link 옵션은 컨테이너 실행 순서의 의존성도 정의해준다는 의미가 있다
# 하지만 현재 deprecated된 옵션이며 추후 삭제될 수 있다.

# 도커 브리지 네트워크를 사용하면 --link 옵션과 동일한 기능을 더욱 손쉽게
# 사용할 수 있으므로 브리지 네트워크를 사용하는 것을 권장한다.   

docker exec -i -t wordpressdb /bin/bash
# exec 명령어를 사용하면 컨테이너 내부에서 명령어를 실행한 뒤 그 결괏값을
# 반환받을 수 있습니다. -i -t 옵션을 추가해 /bin/bash를 상호 입출력이
# 가능한 형태로 exec 명령어를 사용했습니다.

# exec로 실행한 /bin/bash는 exit를 입력해도 컨테이너가 종료되지 않는데, 
# 이는 mysql 프로세스가 컨테이너 안에서 여전히 포그라운드 모드로 작동하고
# 있기 때문입니다.
```

# 2.2.6 도커 볼륨

>도커 이미지로 컨테이너를 생성하면 이미지는 읽기 전용이 되며 컨테이너의 변경 사항만 별도로 저장해서 각 컨테이너의 정보를 보존합니다.
>따라서 컨테이너를 삭제할 경우 원래 이미지에서 변경된 파일, DB 정보 등은 복구할 수 없게 됩니다.
>이를 방지하기 위해 나온 컨테이너의 데이터를 영속적(Persistent) 데이터로 활용할 수 있는 방법이 몇 가지 있습니다.
>그 중 가장 활용하기 쉬운 방법이 볼륨을 활용하는 것입니다.

## 2.2.6.1 호스트 볼륨 공유

```docker
docker run -d \\
--name wordpressdb_hostvolume \\
-e MYSQL_ROOT_PASSWORD=password \\
-e MYSQL_DATABASE=wordpress \\
-v /home/wordpress_db:/var/lib/mysql \\
mysql:8
# windows 환경에서는 \\ 대신 `을 사용
# -v 옵션을 추가해 호스트의 /home/wordpress_db 디렉토리와 컨테이너의
# /var/lib/mysql 디렉터리를 공유한다는 뜻입니다.
# 즉, [호스트의 공유 디렉터리]:[컨테이너의 공유 디렉터리] 형태입니다.

# 호스트의 공유 디렉토리가 존재하지 않아도 자동으로 이를 생성합니다.
# Windows에서는 /home 디렉토리는 존재하지 않기에 C:/Users/admin 디렉토리를
# 사용해야 한다.

# -v 옵션은 동시에 여러 개 사용이 가능하다.

# 만약 기존에 존재하는 디렉토리와 공유를 하게 될 경우 호스트의 디렉토리로
# 새로 생성된 컨테이너의 디렉토리가 덮어씌워지게 된다. (마운트한다.)

docker run -d \\
--name wordpress_hostvolume \\
-e WORDPRESS_DB_HOST=mysql \\
-e WORDPRESS_DB_USER=root \\
-e WORDPRESS_DB_PASSWORD=password \\
--link wordpressdb_hostvolume:mysql \\
-p 15530:80 \\
wordpress
```

## 2.2.6.2 볼륨 컨테이너

```docker
docker run -i -t \\
--name volume_overide \\
-v /home/wordpress_db:/home/testdir_2 \\
alicek106/volume_test

docker run -i -t \\
--name volumes_from_container \\
--volume-from volume_overide \\
ubuntu14.04
# volume_overide 컨테이너에서 볼륨을 공유받는 예제입니다.
# 컨테이너 생성시 --volumes_from 옵션을 설정하면 앞에서 생성한 
# volume_overide 컨테이너의 볼륨 디렉토리를 공유할 수 있습니다.
# 그러나 이는 직접 볼륨을 공유하는 것이 아닌 -v 옵션을 적용한 컨테이너를 
# 통해 공유하는 것입니다.
```

## 2.2.6.3 도커 볼륨

```docker
docker volume create --name myvolume
# 도커 자체에서 제공하는 볼륨 기능을 활용해 데이터를 보존하는 방식입니다.
# 해당 명령어로 도커 볼륨을 생성할 수 있습니다.
# 볼륨은 디렉토리 하나에 상응하는 단위로 도커 엔진에서 관리합니다.

# 도커 볼륨도 호스트 볼륨 공유와 마찬가지로 호스트에 저장함으로써 데이터를
# 보존하지만 파일이 실제로 어디에 저장되는지 사용자는 알 필요가 없습니다.

docker volume ls
# 해당 명령어로 생성된 볼륨을 확인합니다.

docker run -i -t --name myvolume_1 \\
-v myvolume:/root/ \\
ubuntu:14.04

root@60f31cc49256:~# ehco hello, volume! >> /root/volume
# /root 디렉토리에 hello, volume! 이라는 내용을 가진 volume이란 파일을 
# 생성했습니다. 다른 컨테이너도 myvolume 볼륨을 쓰면 볼륨을 활용한
# 디렉토리에 volume 파일이 존재할 것입니다.

docker run -i -t --name myvolume_2 \\
-v myvolume:/root/ \\
ubuntu:14.04

docker inspect --type volume myvolume
# 하지만 docker inspect 명령어를 사용하면 볼륨이 실제 어디에 저장되는지
# 알수 있습니다.
```

> 도커의 모든 명령어는 docker 접두어 다음에 container, image, volume 등을 명시함으로써 특정 구성 단위를 제어하는 명령어를 사용할 수 있습니다. 예를 들어, docker container inspect는 컨테이너의 정보를 출력합니다.

```docker
docker volume inspect myvolume
[
    {
        "CreatedAt": "2025-01-21T14:56:56Z",
        "Driver": "local",
        "Labels": null,
        "Mountpoint": "/var/lib/docker/volumes/myvolume/_data",
        "Name": "myvolume",
        "Options": null,
        "Scope": "local"
    }
]
```

> Driver는 볼륨이 쓰는 드라이버를, Label은 볼륨을 구분하는 라벨을 나타내며, Mountpoint는 해당 볼륨이 실제로 호스트의 어디에 저장됐는지를 의미합니다. 그러나 볼륨을 쓰는 사용자 입장에서 Mountpoint를 알 필요는 없습니다.

```docker
docker run -i -t --name volume_auto -v /root ubuntu:14.04
# 다음과 같이 컨테이너에서 공유할 디렉터리의 위치를 -v 옵션에 입력하면 해당 
# 디렉터리에 대한 볼륨을 자동으로 생성합니다.

docker volume prune
# 컨테이너가 사용하지 않는 모든 볼륨을 삭제하는 명령어
```

# 2.2.7 도커 네트워크

## 2.2.7.1 도커 네트워크 구조

> 도커는 컨테이너에 내부 IP를 순차적으로 할당하며, 이 IP는 컨테이너를 재시작할 때마다 변경될 수 있습니다. 이 내부 IP는 도커가 설치된 호스트, 즉 내부 망에서만 쓸 수 있는 IP이므로 `외부와 연결될 필요`가 있습니다.
> 
> 이 과정은 컨테이너를 시작할 때마다 호스트에 veth… 라는 네트워크 인터페이스를 생성함으로써 이뤄집니다. 도커는 각 컨테이너에 외부와의 네트워크를 제공하기 위해 컨테이너마다 `가상 네트워크 인터페이스`를 **호스트에 생성**하며 이 인터페이스의 이름은 `veth`로 시작합니다. 인터페이스는 사용자가 직접 생성할 필요는 없으며 컨테이너가 생성될 때 도커엔진이 자동으로 생성합니다.
> 
> - 도커가 설치된 호스트에서 `ifconfig`나 `ip addr`과 같은 명령어로 네트워크 인터페이스를 확인하면 `실행 중인 컨테이너 수`만큼 veth로 시작하는 인터페이스가 생성된 것을 알 수 있음
> - 즉 호스트의 veth와 컨테이너의 eth0이 연결되어 통신이 가능한 형태이다.
>     - veth 인터페이스뿐 아니라 docker0이라는 브리지도 존재하는데 docker0 브리지는 각 veth 인터페이스와 바인딩돼 호스트의 eth0와 이어주는 역할을 합니다.
>         - 호스트의 eth0 ↔ docker0 브리지 ↔ 호스트의 veth ↔ 컨테이너의 eth0

## 2.2.7.2 도커 네트워크 기능

> 컨테이너를 생성하면 기본적으로 `docker0 브리지`를 통해 외부와 통신할 수 있는 환경을 사용할 수 있지만 사용자의 선택에 따라 `여러 네트워크 드라이버`를 쓸 수도 있습니다. 도커가 자체적으로 제공하는 대표적인 네트워크 드라이버로는 `브리지(bridge), 호스트(host), 논(none), 컨테이너(container), 오버레이(overlay)`가 있습니다.
> 
> `서드파티 플러그인 솔루션`으로는 `weave, flannel, openvswitch` 등이 있으며, **더 확장된 네트워크 구성**을 위해 활용됩니다. 이번 장에서는 도커 자체만으로 손쉽게 쓸 수 있는 브리지, 호스트, 논, 컨테이너를 설명하겠습니다.

```docker
>> docker network ls
NETWORK ID     NAME      DRIVER    SCOPE
5bc3aae2ce99   bridge    bridge    local
422b9b59fe57   host      host      local
a51e3aa65a50   none      null      local
# 이미 브리지, 호스트, 논 네트워크가 있음을 알 수 있음. 브리지 네트워크는 컨테이너를
# 생성할 때 자동으로 연결되는 docker0 브리지를 활용하도록 설정돼 있습니다.
# 이 네트워크는 172.17.0.x IP 대역을 컨테이너에게 순차적으로 할당합니다.

>> docker network inspect bridge
[
    {
        "Name": "bridge",
        "Id": "5bc3aae2ce99b6f7c03d1ecdd558fb1d0c676671d9d9bb24068ffecf07240c80",
        "Created": "2025-01-21T09:47:11.210406792Z",
        "Scope": "local",
        "Driver": "bridge",
        "EnableIPv6": false,
        "IPAM": {
            "Driver": "default",
            "Options": null,
            "Config": [
                {
                    "Subnet": "172.17.0.0/16",
                    "Gateway": "172.17.0.1"
                }
            ]
        },
 ...
        "Containers": {},
 ...
 ]
 # docker network inspect 명령어로 서브넷과 게이트 웨이가 172.17.0.0/16과 
 # 172.17.0.1로 설정돼 있습니다. 또한 브리지 네트워크를 사용 중인 컨테이너 목록을
 # Containers 항목에서 확인할 수 있습니다
 
```

### 브리지 네트워크

> 이전 2.2.7.1절에서 설명한 docker0브리지와 비슷하게 `브리지 네트워크`는 docker0이 아닌 **사용자 정의 브리지를 새로 생성해 각 컨테이너에 연결하는 네트워크 구조**입니다. 컨테이너는 연결된 브리지를 통해 외부와 통신할 수 있습니다.

```docker
>> docker network create --driver bridge mybridge
# 브리지 타입의 네트워크를 생성하는 명령어
# 해당 브리지는 docker inspect 명령어로 알아보게 될 경우 172.18.0.0/16의 서브넷과
# 172.18.0.1의 내부 IP를 가진다는 것을 알 수 있다.

>> docker run -i -t --name mynetwork_container --net mybridge ubuntu:14.04
# 새로 정의한 브리지 타입의 네트워크를 사용하도록 컨테이너를 생성할 경우 해당 컨테이너는
# 내부 IP 주소로 172.18.0.2를 사용하게 된다.

>> docker network disconnect mybridge mynetwork_container
# 사용자 정의 네트워크에 해당 명령어로 컨테이너를 뗄 수 있다.
>> docker network connect mybridge mynetwork_container
# 사용자 정의 네트워크에 해당 명령어로 컨테이너를 붙일 수 있다.

# 단, 이번 장에서 설명하는 논, 호스트 네트워크 등과 같은 특별한 네트워크 모드에는 
# connect/disconnect 명령어를 사용할 수 없습니다.
# 브리지와 오버레이처럼 특정 IP 대역을 갖는 네트워크 모드에만 사용 가능합니다.

>> docker network create --driver=bridge \\
--subnet=172.72.0.0/16 \\
--ip-range=172.72.0.0/24 \\
--gateway=172.72.0.1 \\
my_custom_network
# 위와 같이 네트워크의 서브넷, 게이트웨이, IP 할당 범위 등을 임의로 설정할 수 있다.
```

### 호스트 네트워크

> 네트워크를 호스트로 설정하면 `호스트의 네트워크 환경`을 그대로 쓸 수 있습니다. 위의 브리지 드라이버 네트워크와 달리 호스트 드라이버의 네트워크는 별도로 생성할 필요 없이 기존의 host라는 이름의 네트워크를 사용합니다.

```docker
>> docker run -i -t --name network_host --net host ubuntu:14.04
# 네트워크를 host로 설정한 컨테이너의 내부에서 네트워크 환경을 확인하면 호스트와 같은 것
# 을 알 수 있습니다.

# 호스트 머신에서 설정한 호스트 이름도 컨테이너가 물려받기 때문에 컨테이너의 호스트
# 이름도 무작위 16진수가 아닌 도커 엔진이 설치된 호스트 머신의 호스트 이름으로 설정된다.

# 컨테이너의 네트워크를 호스트로 설정하면 컨테이너 내부의 애플리케이션을 별도의
# 포트 포워딩 없이 바로 서비스할 수 있습니다.
```

### 논 네트워크

> none은 말 그대로 `아무런 네트워크를 쓰지 않는 것`을 뜻합니다. 다음과 같이 컨테이너를 생성하면 외부와 연결이 단절됩니다.

```docker
>> docker run -i -t --name network_none --net none ubuntu:14.04
# --net 옵션으로 none을 설정한 컨테이너 내부에서 네트워크 인터페이스를 확인하면
# 로컬호스트를 나타내는 lo 외에는 존재하지 않는 것을 알 수 있습니다.
```

### 컨테이너 네트워크

> 컨테이너 네트워크를 사용하면 `다른 컨테이너의 네트워크 네임스페이스 환경`을 공유할 수 있습니다. 공유되는 속성은 내부 IP, 네트워크 인터페이스의 맥(MAC) 주소 등입니다.

```docker
>> docker run -i -t -d --name network_container_1 ubuntu:14.04

>> docker run -i -t -d --name network_container_2 \\
--net container:network_container_1 \\
ubuntu:14.04
```

### 브리지 네트워크와 --net-alias

> 브리지 타입의 네트워크와 run 명령어의 --net-alias 옵션을 함께 쓰면 특정 호스트 이름으로 컨테이너 여러 개에 접근할 수 있습니다. 위에서 생성한 mybridge 네트워크를 이용해 컨테이너를 3개 생성할 때, --net-alias 옵션의 값은 alicek106으로 설정했으며, 다른 컨테이너에서 alicek106이라는 호스트 이름으로 아래 3개의 컨테이너에 접근할 수 있습니다.

```docker
>> docker run -i -t -d --name network_alias_contianer_1 \\
--net mybridge \\
--net-alias alicek106 ubuntu:14.04

>> docker run -i -t -d --name network_alias_contianer_2 \\
--net mybridge \\
--net-alias alicek106 ubuntu:14.04

>> docker run -i -t -d --name network_alias_contianer_3 \\
--net mybridge \\
--net-alias alicek106 ubuntu:14.04

>> docker inspect network_alias_container_1 | grep IPAddress 
# Linux
OR
>> docker inspect network_alias_contianer_1 | findstr "IPAddress" 
# Windows
            "SecondaryIPAddresses": null,
            "IPAddress": "",
                    "IPAddress": "172.18.0.2",
# 첫 번쨰 컨테이너의 IP 주소가 172.18.0.2이므로 두 번째, 세 번째 컨테이너는
# 각각 172.18.0.3, 172.18.0.4일 것입니다. 세 개의 컨테이너에 접근할 컨테이너를
# 생성한 뒤 alicek106이라는 호스트 이름으로 ping 요청을 해보면 결과는 다음과 같습니다
>> docker run -i -t --name network_alias_ping --net mybridge ubuntu:14.04

root@a8dd0bfa0223:/# ping -c 1 alicek106
PING alicek106 (172.18.0.4) 56(84) bytes of data.
64 bytes from network_alias_contianer_3.mybridge (172.18.0.4): icmp_seq=1 ttl=64 time=0.041 ms

--- alicek106 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 0.041/0.041/0.041/0.000 ms
root@a8dd0bfa0223:/# ping -c 1 alicek106
PING alicek106 (172.18.0.3) 56(84) bytes of data.
64 bytes from network_alias_contianer_2.mybridge (172.18.0.3): icmp_seq=1 ttl=64 time=0.049 ms

--- alicek106 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 0.049/0.049/0.049/0.000 ms
root@a8dd0bfa0223:/# ping -c 1 alicek106
PING alicek106 (172.18.0.2) 56(84) bytes of data.
64 bytes from network_alias_contianer_1.mybridge (172.18.0.2): icmp_seq=1 ttl=64 time=0.026 ms

--- alicek106 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 0.026/0.026/0.026/0.000 ms
```

> 컨테이너 3개의 IP로 각각 ping이 전송된 것을 확인할 수 있습니다. 매번 달라지는 IP를 결정하는 것은 별도의 알고리즘이 아닌 `라운드로빈` 방식입니다. 이것이 가능한 이유는 `도커 엔진에 내장된 DNS`가 alicek106이라는 `호스트 이름`을 --net-alias 옵션으로 alicek106을 설정한 `컨테이너`로 변환하기 때문입니다.

![[image-2.17.png]]

> 도커의 `DNS`는 `호스트 이름으로 유동적인 컨테이너를 찾을 때` 주로 사용됩니다. 가장 대표적인 예가 `--link 옵션`인데, 이는 컨테이너의 IP가 변경돼도 별명으로 컨테이너를 찾을 수 있게 DNS에 의해 자동으로 관리됩니다. 단 이 경우는 `디폴트 브리지 네트워크의 컨테이너 DNS`라는 점이 다릅니다.

> 💡 GPT에 검색 결과 디폴트 브리지 네트워크의 경우, 컨테이너의 IP가 변경되어도 링크된 컨테이너의 별명으로 접근할 수 있는 것은 사실이다.
> 하지만 이는 DNS를 통한 연결이 아닌, 연결된 컨테이너의 이름이 /etc/hosts 파일에 정적으로 추가되기 때문에 가능한 것이라고 한다.
> 그래서 Docker의 내장 DNS 서버를 사용한다는 말은 틀렸다고 한다.

> `--net-alias 옵션` 또한 --link 옵션과 비슷한 원리로 작동합니다. 도커는 기본 브리지 네트워크가 아닌 `사용자가 정의한 브리지 네트워크에 사용되는 내장 DNS 서버`를 가지며, DNS의 IP는 127.0.0.11입니다. mybridge라는 이름의 네트워크에 속한 3개의 컨테이너는 run으로 생성할 때 --net-alias 옵션에 alicek106이라는 값을 입력했으며, 이 컨테이너의 IP는 DNS 서버에 alicek106이라는 호스트 이름으로 등록됩니다.

> mybridge 네트워크에 속한 컨테이너에서 alicek106이라는 호스트 이름으로 접근하면 DNS 서버는 라운드 로빈 방식을 이용해 컨테이너의 IP 리스트를 반환합니다. ping 명령어는 이 IP 리스트에서 첫 번째 IP를 사용하므로 매번 다른 IP로 ping을 전송합니다.