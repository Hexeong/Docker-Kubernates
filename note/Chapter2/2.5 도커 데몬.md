>[!note]
>지금까지 도커를 사용하는 방법을 설명했습니다. 가장 먼저 알아야 할 컨테이너부터 시작해서 컨테이너의 밑바탕이 되는 이미지, 그리고 그 이미지를 생성할 수 있는 Dockerfile을 알아봤습니다.
>그렇다면 이제는 도커 자체를 다뤄볼 차례입니다. 도커 자체에 사용할 수 있는 여러 옵션을 익히면 컨테이너와 이미지를 좀 더 쉽게 사용할 수 있을 뿐더러 도커를 이용한 개발이 더욱 수월해질 것입니다.

# 2.5.1 도커의 구조

도커를 사용할 때 docker라는 명령어를 맨 앞에 붙여서 사용해왔습니다. 그렇다면 도커는 실제로 어디에 있는 걸까요? which 명령어로 도커 명령어의 위치를 확인할 수 있습니다.

---

```powershell
> which docker
/usr/bin/docker

# 보다시피 도커 명령어는 /usr/bin/docker에 위치한 파일을 통해 사용되고 있습니다. 이번에는 실행 중인 도커 프로세스를 확인해보겠습니다.

> tasklist | findstr docker
com.docker.backend.exe       31224 Console                    1     58,132 K    
com.docker.backend.exe       31368 Console                    1    121,444 K    
com.docker.dev-envs.exe      31736 Console                    1     13,736 K    
com.docker.build.exe         30736 Console                    1     33,744 K
# > ps aux | grep docker, in Linux
# 실행 중인 프로세스의 목록을 출력하는 명령어입니다.
# 컨테이너나 이미지를 다루는 명령어는 /usr/bin/docker에서 실행되지만, 사실 도커 엔진의 프로세스는 /usr/bin/dockerd 파일로 실행되고 있습니다.
# 현재는 windows에서 실행중이기에 com.docker.backend.exe가 도커 엔진 프로세스입니다.
# 이는 docker 명령어가 실제 도커 엔진이 아닌 클라이언트로서의 도커이기 때문입니다.
```

>[!important]
> 도커의 구조는 크게 두 가지로 나뉩니다. 하나는 `클라이언트`로서의 도커이고, 하나는 `서버`로서의 도커입니다.
> 실제로 컨테이너를 생성하고 실행하며 **이미지를 관리하는 주체**는 `도커 서버`이고, 이는 `dockerd 프로세스`로서 동작합니다.
>  
> 도커 엔진은 외부에서 `API 입력`을 받아 도커 엔진의 기능을 수행하는데, 도커 프로세스가 실행되어 서버로서 입력을 받을 준비가 된 상태를 `도커 데몬`이라고 이야기합니다.
> 
> 다른 하나는 도커 클라이언트입니다. 도커 데몬은 API 입력을 받아 도커 엔진의 기능을 수행하는데, 이 API를 사용할 수 있도록 CLI를 제공하는 것이 도커 클라이언트입니다. 
> 사용자가 `docker로 시작하는 명령어`를 입력하면 도커 클라이언트를 사용하는 것이며, 도커 클라이언트는 입력된 명령어를 `로컬에 존재하는 도커 데몬`에게 **API로서 전달**합니다. 이때 도커 클라이언트는 `/var/run/docker.sock`에 위치한 `유닉스 소켓`을 통해 도커 데몬의 API를 호출합니다.
> 
> 도커 클라이언트가 사용하는 유닉스 소켓은 같은 호스트 내에 있는 도커 데몬에게 명령을 전달할 때 사용됩니다. tcp로 원격에 있는 도커 데몬을 제어하는 방법도 있지만 이는 뒤에서 자세히 설명하겠습니다.

![그림 2.61](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fb5CU07%2Fbtrh0ElJHJ1%2F8wRlg0MqKOpJvNL7xqhg21%2Fimg.jpg)

>[!summary]
>즉, `터미널`이나 `PuTTY` 등으로 도커가 설치된 호스트에 접속해 `docker 명령어`를 입력하면 **아래와 같은 과정**으로 도커가 제어됩니다.
>
>1. 사용자가 `docker version` 같은 **도커 명령어**를 입력합니다.
>2. `/usr/bin/docker` 는 `/var/run/docker.sock` **유닉스 소켓**을 사용해 도커 데몬에게 명령어를 전달합니다.
>3. 도커 데몬은 이 명령어를 파싱하고 명령어에 해당하는 작업을 수행합니다.
>4. 수행 결과를 도커 클라이언트에게 반환하고 사용자에게 결과를 출력합니다.
>   
>이것은 아무런 설정을 하지 않았을 때 일반적으로 도커 데몬을 제어하는 순서입니다. 도커 데몬에 각종 옵션을 추가해 실행한다면 위 순서에 별도의 과정이 포함될 수 있습니다.

>[!warning]
>Windows 환경에서 Docker를 설치하면, **유닉스 기반의 `/var/run/docker.sock` 소켓을 사용하지 않는 대신**, Docker는 Windows에서 `Windows 네이티브 방식`으로 동작하며, `named pipe`를 사용하여 도커 데몬과 통신합니다.
>
>Windows에서 Docker는 일반적으로 `\\.\pipe\docker_engine` 이라는 **네임드 파이프를 사용**합니다. 이 파이프는 Docker CLI가 도커 데몬과 통신하는 데 사용되며, 이는 유닉스 소켓과 유사한 역할을 합니다.

# 2.5.2 도커 데몬 실행

도커 데몬은 일반적으로 아래와 같은 명령어로 시작, 정지할 수 있습니다. 우분투에서 도커가 설치되면 자동으로 서비스로 등록되므로 호스트가 재시작하더라도 자동으로 실행됩니다.

---

```powershell
> service docker start
> service docker stop
# in Unix

> net start com.docker.service
> net stop com.docker.service
# in Windows
# 실제로 해본 결과 Docker Desktop의 Docker Engine 버전은 27.5.1로 해당 명령어는 도커 클라이언트인 Docker Desktop Service 서비스를 아래 문구와 함께 시작했습니다.
# Docker Desktop Service 서비스가 잘 시작되었습니다.
# 이후 보인 tasklist | findstr docker 명령어에선 com.docker.services가 실행되고 있었음.
# 제가 보기에 서비스 시작이 아닌 Console 앱인 com.docker.backend.exe와 com.docker.dev-envs.exe가 실행되고 있어야 도커 데몬이 정상작동 하는 듯 합니다.

# 파일을 찾아본 결과 C:\Program Files\Docker\Docker\resources\com.docker.backend.exe
# 콘솔 앱을 실행시킨 경우, Windows에서 도커 데몬이 실행됩니다. 따라서 dockerd 역할을 해당 콘솔 앱 파일이 대체하고 있습니다. 이 경우 도커 데몬이 Foreground에서 돌아가게 됩니다.

> systemctl enable docker
# in 레드햇 계열
# 레드햇 계열의 OS는 도커를 설치해도 자동으로 실행되도록 설정되지는 않습니다. 도커를 자동으로 실행하도록 설정하려면 아래의 명령어로 docker 서비스를 활성화합니다.
```

>[!note]
>앞에서 설명했듯이 도커 서비스는 **dockerd로 도커 데몬을 실행**합니다. 그러나 서비스를 사용하지 않고 직접 도커 데몬을 실행할 수도 있습니다. 도커 서비스를 정지한 뒤 명령어로 도커를 직접 실행해 봅시다. **`dockerd` 명령어** 또한 `/usr/bin/dockerd` 로서 존재하기 때문에 docker 명령어와 같이 바로 사용할 수 있습니다.
>
>```powershell
>> service docker stop
>> dockerd 
># in Unix
>
>> C:\Program Files\Docker\Docker\resources\com.docker.backend.exe
># in Windows, in 27.5.1 Docker engine version
>```
>
>dockerd를 입력하면 도커 데몬이 실행됩니다. 그럼 도커 데몬에 대한 각종 정보가 출력되는데 마지막에 **유닉스 소켓(/var/run/docker.sock)에서 입력(listen)을 받을 수 있는 상태라는 메세지**가 출력됩니다. 터미널을 하나 더 연 다음 도커 명령어를 입력하면 이전처럼 도커를 사용할 수 있습니다.

