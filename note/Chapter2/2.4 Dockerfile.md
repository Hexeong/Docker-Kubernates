# 2.4.1 이미지를 생성하는 방법

> 개발한 애플리케이션을 컨테이너화할 때 가장 먼저 생각나는 방법은 아래와 같습니다.
> 
> 1. 아무것도 존재하지 않는 이미지(우분투, CentOS 등)로 컨테이너를 생성
> 2. 애플리케이션을 위한 환경을 설치하고, 소스코드 등을 복사해 잘 동작하는 것을 확인
> 3. 컨테이너를 이미지로 커밋(commit)

![그림 2.54](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F4KwxR%2Fbtq99nTDvzv%2FhjpG62oSy1kBaF6LVmdxok%2Fimg.png)

> 이 방법을 사용하면 애플리케이션이 동작하는 환경을 구성하기 위해 **일일이 수작업으로 패키지를 설치하고 소스코드를 Git에서 복제하거나 호스트에서 복사해야 합니다.** 물론 직접 컨테이너에서 애플리케이션을 구동해보고 이미지로 커밋하기 때문에 이미지의 동작을 보장할 수 있다는 점도 있습니다.

![그림 2.55](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcjHEhC%2FbtradSdLP9y%2FONv22oZe3SbuxH70AUP611%2Fimg.png)

> 도커는 위와 같은 일련의 과정을 손쉽게 기록하고 수행할 수 있는 `빌드(build)` 명령어를 제공합니다. 
> 완성된 이미지를 생성하기 위해 컨테이너에 설치해야 하는 패키지, 추가해야 하는 소스코드, 실행해야 하는 명령어와 셸 스크립트 등을 **하나의 파일에 기록해 두면** 도커는 이 파일을 읽어 `컨테이너에서 작업을 수행한 뒤` 이미지로 만들어냅니다.

>[!NOTE]
> 이와 같이 Dockerfile을 사용하는 이유는 이미지를 생성하는 방법을 기록하는 것뿐만 아니라 이미지의 빌드, 배포 측면에서도 매우 유리합니다. 애플리케이션에 필요한 패키지 설치 등을 명확히 할 수 있고 이미지 생성을 자동화 할 수 있으며, 쉽게 배포할 수 있기 때문입니다.

>[!tip]
>애플리케이션을 배포할 때 이미지 자체를 배포하는 대신 이미지를 생성하는 방법을 기록해 놓은 Dockerfile을 배포할 때도 있습니다. 
>배포되는 이미지를 신뢰할 수 없거나 직접 이미지를 생성해서 사용하고 싶다면 도커 허브에 올려져 있는 Dockerfile로 빌드하는 것도 하나의 방법입니다.

# 2.4.2 Dockerfile 작성

> Dockerfile을 사용하기 위한 간단한 시나리오로 웹 서버 이미지를 생성하는 예를 설명하겠습니다. 먼저 이번 절의 예제에서 사용할 디렉토리를 생성하고, 디렉터리 안에 HTML 파일을 미리 만들어둡니다.

```powershell

먼저 이번 절의 예제에서 사용할 디렉토리를 생성하고, 디렉터리 안에 HTML 파일을 미리 만들어둡니다.

# mkdir dockerfile && cd dockerfile
# echo test >> test.html

# ls
test.html

새롭게 생성한 디렉터리 내부에서 아래의 내용으로 Dockerfile이라는 이름의 파일을 저장합니다.
아래의 Dockerfile은 이미지에 아파치 웹 서버를 설치한 뒤, 로컬에 있는 test.html 파일을 웹 서버로 접근할 수 있는 컨테이너의 디렉터리인 /var/www/html에 복사합니다.

# vi Dockerfile
```
```Dockerfile
FROM ubuntu:14.04
MAINTAINER alicek106
LABEL "purpose"="practice"
RUN apt-get update
RUN apt-get install apache2 -y
ADD test.html /var/www/html
WORKDIR /var/www/html
RUN ["/bin/bash", "-c", "echo hello >> test.html"]
EXPOSE 80
CMD apachectl -DFOREGROUND
```

>[!warning]
>도커 엔진은 Dockerfile을 읽어 들일 때 기본적으로 현재 디렉토리에 있는 Dockefile을 선택합니다.
>또한 Dockerfile은 빈(Empty) 디렉터리에 저장하는 것이 좋은데, 이는 이미지를 빌드할 때 사용하는 컨텍스트(Context) 때문입니다.

> Dockerfile에서 사용되는 명령어는 여러 가지가 있습니다. Dockefile의 명령어는 위에서 아래로 한줄씩 차례대로 실행됩니다.


- `FROM` : 생성할 이미지의 **베이스**가 될 이미지를 뜻합니다. `FROM` 명령어는 Dockerfile을 작성할 때 반드시 한 번 이상 입력해야 하며, 이미지 이름의 포맷은 `docker run` 명령어에서 이미지 이름을 사용했을 때와 같습니다. 사용하려는 이미지가 없다면 자동으로 `pull` 합니다. 

- `MAINTAINER` : 이미지를 생성한 개발자의 정보를 나타냅니다. 일반적으로 Dockerfile을 작성한 사람과 연락할 수 있는 이메일 등을 입력합니다. 단, `MAINTAINER`는 **도커 1.13.0 버전** 이후로 사용되지 않습니다. 대신 아래와 같은 `LABEL`로 교체해 표현할 수 있습니다.
>[!tip]
>단, `MAINTAINER`는 **도커 1.13.0 버전** 이후로 사용되지 않습니다. 대신 아래와 같은 `LABEL`로 교체해 표현할 수 있습니다.

- `LABEL` : 이미지에 메타데이터를 추가합니다. 메타데이터는 **"키:값"의 형태**로 저장되며, 여러 개의 메타데이터가 저장될 수 있습니다. 추가된 메타데이터는 `docker inspect` 명령어로 이미지의 정보를 구해서 확인할 수 있습니다.

- RUN : 이미지를 만들기 위해 컨테이너 내부에서 명령어를 실행합니다.
>[!warning]
>단, Dockerfile을 이미지로 빌드하는 과정에서 별도의 입력이 불가능하기 때문에 추가 입력에 대한 설정을 커맨드 상으로 해두어야 합니다. (e.g. `apt-get install apache2 -y` 명령어의 `-y` 옵션)
>
>만약 별도의 입력을 받아야 하는 `RUN`이 있다면 build 명령어는 이를 오류로 간주하고 빌드를 종료합니다.
>또한, 해당 `RUN` 명령어는 **JSON 배열의 입력 방식을 따르기에** 셸을 실행하지 않습니다. 따라서 환경변수와 같이 셸 스크립트를 사용해야 하는 경우 `["sh", "-c" "echo $MY_ENV"]` 와 같이 사용하는 것이 좋습니다.

- `ADD` : 파일을 이미지에 추가합니다. 추가하는 파일은 Dockerfile이 위치한 디렉터리인 **컨텍스트**(Context)에서 가져옵니다.
>[!NOTE]
>해당 명령어 또한 **JSON 배열**의 형태로 `["추가할 파일 이름", ... , "컨테이너에 추가될 위치"]`와 같이 여러 개를 지정하여 추가할 수 있습니다.

- `WORKDIR` : 명령어를 실행할 디렉터리를 나타냅니다. bash 셸에서 cd 명령어를 입력하는 것과 같은 기능을 합니다.

- `EXPOSE` : Dockerfile 빌드로 생성된 이미지에서 노출할 포트를 설정합니다. 이는 단지 컨테이너의 특정 포트를 사용할 것임을 나타내는 것 뿐입니다. 따라서 컨테이너 시작시 -p로 컨테이너와 호스트의 포트를 바인딩해줘야 합니다. 

- `CMD` : `CMD`는 컨테이너가 시작될 때마다 실행할 명령어(커맨드)를 설정하며, **Dockerfile에서 한 번만** 사용할 수 있습니다. Dockerfile에 `CMD`를 명시함으로써 이미지에 `apachectl -DFOREGROUND`라는 커맨드를 내장하면 컨테이너를 생성할 때 별도의 커맨드를 입력하지 않아도 이미지에 내장된 커맨드가 적용되어 컨테이너가 시작될 때 자동으로 아파치 웹 서버가 실행될 것입니다.
>[!tip]
>아파치 웹 서버는 하나의 터미널을 차지하는 포그라운드 모드로 실행되기 때문에 -d 옵션을 사용해 detached 모드로 컨테이너를 생성해야 합니다.

>[!NOTE]
>즉, `CMD`는 run 명령어의 이미지 이름 뒤에 입력하는 커맨드와 같은 역할을 하지만 `docker run` 명령어에서 커맨드 명령줄 인자를 입력하면 Dockerfile에서 사용한 `CMD` 명령어는 `run`의 커맨드로 **덮어 쓰입니다**. 이와 마찬가지로 ubuntu:14.04 이미지에 기본적으로 내장된 커맨드인 `/bin/bash` 또한 `Dockerfile의 CMD`에 의해 **덮어 쓰입니다**.

>[!warning]
>`RUN`과 `CMD` 두 명령어의 차이는 실행 시점에 있다. `RUN`은 이미지를 빌드할 때 `한 번` 실행되는 명령어이고, 만들어진 이미지에 대해서 `컨테이너로 시작할 때마다` `CMD` 명령어가 실행된다는 점을 이해해야 한다.

