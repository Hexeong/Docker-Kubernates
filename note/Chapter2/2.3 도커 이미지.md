> [!info]
> 모든 컨테이너는 이미지를 기반으로 생성되므로 이미지를 다루는 방법은 도커 관리에서 빼놓을 수 없는 부분입니다. 이미지의 이름을 구성하는 저장소, 이미지 이름, 태그를 잘 관리하는 것 뿐만 아니라 이미지가 어떻게 생성되고 삭제되는지, 이미지의 구조는 어떻게 돼 있는지 등을 아는 것 또한 중요합니다. 이번 장에서는 이미지를 관리하는 기본적인 방법을 살펴보겠습니다.

> 도커는 기본적으로 `도커 허브(Docker Hub)`라는 `중앙 이미지 저장소`에서 이미지를 내려받습니다. 도커 허브는 도커가 공식적으로 제공하고 있는 이미지 저장소로서, 도커 계정을 갖고 있다면 `누구든지` 이미지를 올리고 내려받을 수 있기 때문에 다른 사람들에게 이미지를 쉽게 공유할 수 있습니다.

>[!important]
>단, 도커 허브는 누구나 이미지를 올릴 수 있기 때문에 공식(Official) 라벨이 없는 이미지는 사용법을 찾을 수 없거나 제대로 동작하지 않을 수 있습니다.
>또한 이미지 저장소를 다른 사람들에게 공개하지 않기 위해 비공개(Private) 저장소를 사용하려면 비공개 저장소의 수에 따라 요금을 지불해야 합니다. 
>이를 해결하기 위해 도커 이미지 저장소를 직접 구축해 비공개로 사용할 수도 있다는 점을 알아두시면 좋겠습니다.

>[!tip]
>도커 허브에 어떤 이미지가 있는지 확인하기 위해 도커 허브 사이트를 직접 접속해서 찾아볼 수 있지만, 도커 엔진에서 docker search 명령어를 사용할 수도 있습니다.

>[!tip]
>docker search 명령어는 도커 허브에서 이미지를 검색하며, 도커 허브 이미지임을 명시하기 위해 docker.io/ubuntu와 같이 docker.io 접두어를 사용할 수도 있습니다. 이는 다른 이미지 저장소와 구분하기 위함입니다.

# 2.3.1 도커 이미지 생성

>[!info]
>앞에서처럼 `docker search`를 통해 검색한 이미지를 pull 명령어로 내려받아 사용할 수도 있지만 도커로 개발하는 많은 경우에는 컨테이너에 애플리케이션을 위한 특정 개발 환경을 직접 구축한 뒤 사용자만의 이미지를 직접 생성해야 할 것입니다. 이를 위해 컨테이너 안에서 작업한 내용을 이미지로 만드는 방법을 먼저 설명하겠습니다.

```docker
다음 명령어를 입력해 이미지로 만들 컨테이너를 생성합니다. 컨테이너 내부에 first라는 이름의 파일을 하나 생성해 기존의 이미지로부터 변경하상을 만듭니다.

# docker run -i -t --name commit_test ubuntu:14.04
root@09a6f0f4cb0d:/# echo test_first >> first

first라는 파일을 만들어 ubuntu:14.04 이미지로부터 변경 사항을 만들었다면 컨테이너에서 호스트로 빠져나와 docker commit 명령어를 입력해 컨테이너를 이미지로 만듭니다. docker commit 명령어의 형식은 아래와 같습니다. 먼저 commit의 옵션을 지정하고 커밋할 컨테이너의 이름을 명시한 뒤 생성될 이미지의 이름을 입력합니다.

# docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]

다음 명령은 commit_test라는 컨테이너를 commit_test:first라는 이름의 이미지로 생성합니다.

# docker commit \
-a "Hexeong" -m "my first commit" \
commit_test \
commit_test:first

-a 옵션은 author를 뜻하며, 이미지의 작성자를 나타내는 메타데이터를 이미지에 포함시킵니다.
-m 옵션은 커밋 메세지를 뜻하며, 이미지에 포함될 부가 설명을 입력합니다.
```

# 2.3.2 이미지 구조 이해

>[!info]
>위와 같이 컨테이너를 이미지로 만드는 작업은 commit 명령어로 쉽게 수행할 수 있습니다. 그러나 이미지를 좀 더 효율적으로 다루기 위해 컨테이너가 어떻게 이미지로 만들어지며, 이미지의 구조는 어떻게 돼 있는지 알 필요가 있습니다. 다음 명령어를 입력해 이미지의 좀 더 자세한 정보를 확인해봅시다.

>[!tip]
>inspect 명령어는 컨테이너뿐만 아니라 네트워크, 볼륨, 이미지 등 모든 도커 단위의 정보를 얻을 때 사용할 수 있습니다. 단, 이름이 중복될 경우 컨테이너에 대해 먼저 수행되므로 --type을 명시하는 것이 좋습니다.

```docker
# docker inspect ubuntu:14.04
# docker inspect commit_test:first
# docker inspect commit_test:second

여기서 주의 깊게 볼 정보는 아랫부분에 위치한 Layers 항목입니다. ubuntu:14.04, commit_test:first, commit_test:second에 대한 각 Layers 항목은 다음과 같습니다. 16진수 해시 값 중 뒷부분을 생략했으며 ID 값은 아래 이미지와 다를 수 있습니다. 다음 그림은 각 이미지에 대한 inspect 명령어의 출력 결과 중 Layers 항목만 나타낸 것입니다.
```

![그림 2.36 ~ 그림 2.37](https://blog.kakaocdn.net/dn/Qy3mG/btq90lHWD2M/FKFMF5hSFgF8Sv76j00nT1/img.png)

> docker images에서 위 3개의 이미지 크기가 각각 188MB라고 출력돼도 188MB 크기의 이미지가 3개 존재하는 것은 아닙니다. 이미지를 커밋할 때 컨테이너에서 변경된 사항만 새로운 레이어로 저장하고, 그 레이어를 포함해 새로운 이미지를 생성하기 때문에 전체 이미지의 실제 크기는 188MB + first 파일의 크기 + second 파일의 크기가 됩니다.

>[!tip]
>이러한 이미지의 레이어 구조는 docker history 명령어를 통해 좀 더 쉽게 확인할 수 있습니다.

> 이번에는 생성한 이미지를 삭제해봅시다.

```docker
# docker rmi commit_test:first

이미지를 삭제할 경우 해당 이미지를 사용중인 컨테이너가 존재할 경우 삭제할 수 없습니다. 물론 -f 옵션을 추가해 이미지를 강제 삭제할 수 있지만 실제로 삭제하지 않고 이미지 이름만 삭제하기 때문에 의미가 없습니다. 이러한 이미지를 댕글링(dangling) 이미지라고 합니다. 댕글링 이미지는 아래 명령어로 별도로 확인 가능합니다.

# docker images -f dangling=true
```

>[!note]
>이처럼 레이어에 대한 개념을 생각하면서 이미지를 관리하면 효율적인 관리가 가능해집니다.

# 2.3.3 이미지 추출

> 도커 이미지를 별도로 저장하거나 옮기는 등 **필요에 따라 이미지를 단일 바이너리 파일로 저장**해야 할 때가 있습니다.
> `docker save` 명령어를 사용하면 컨테이너의 커맨드, 이미지 이름과 태그 등 이미지의 모든 메타데이터를 포함해 하나의 파일로 추출할 수 있습니다.

```docker
# docker save -o ubuntu_14_04.tar ubuntu:14.04

-o : 해당 옵션에는 추출될 파일명을 입력합니다.
```

> 추출된 이미지는 `load` 명령어로 도커에 다시 로드할 수 있습니다. `save`명령어로 추출된 이미지는 이미지의 모든 메타데이터를 포함하기 때문에 `load`명령어로 이미지를 로드하면 **이전의 이미지와 완전히 동일한 이미지가 도커 엔진에 생성됩니다**.

>[!tip]
>`save`, `load` 명령어와 유사하게 사용할 수 있는 명령어로 `export`, `import`가 있습니다. `docker commit` 명령어로 컨테이너를 이미지로 만들면 컨테이너에서 변경된 사항 뿐만 아니라 컨테이너가 생성될 때 입력한 컨테이너 설정 등도 이미지와 함께 저장됩니다.

>[!warning]
>그러나 `export` 명령어는 컨테이너의 파일시스템을 tar 파일로 추출하며 컨테이너 및 이미지에 대한 설정 정보를 저장하지 않습니다.

```docker
# docker export -o rootFS.tar mycontainer
# docker import rootFS.tar myimage:0.0
```

>[!warning]
>그러나 이미지를 단일 파일로 저장하는 것은 효율적인 방법이 아닙니다. 추출된 이미지는 레이어 구조의 파일이 아니기에 여러 버전의 이미지를 추출하면 이미지 용량을 각기 차지하게 되어 메모리 효율성이 떨어집니다.

# 2.3.4 이미지 배포

> 이미지를 생성했다면 이를 다른 도커 엔진에 배포할 방법이 필요합니다. `save`나 `export`와 같은 방법으로 이미지를 단일 파일로 추출해서 배포할 수도 있지만 이미지 파일의 크기가 너무 크거나 도커 엔진의 수가 많다면 이미지를 파일로 배포하기 어렵습니다.
> 또한 도커의 이미지 구조인 레이어 형태를 이용하지 않으므로 **매우 비효율적입니다**.

> 이를 해결하는 첫 번째 방법은 도커에서 공식적으로 제공하는 **도커 허브 이미지 저장소**를 사용하는 것입니다. 도커 허브는 도커 이미지를 저장하기 위한 **클라우드 서비스**라고 생각하면 이해하기 쉽습니다. 
> 사용자는 단지 이미지를 올리고(docker push) 내려받기(docker pull)만 하면 되므로 매우 간단하게 사용할 수 있습니다.

>[!warning]
>단, 결제를 하지 않으면 비공개(Private) 저장소의 수에 제한이 있다는 것이 단점입니다. 공개(Public) 저장소는 무료로 사용할 수 있으므로 만든 이미지를 다른 사용자에게도 공개해도 상관없다면 도커 허브를 사용하는 것도 좋은 선택입니다.

>두 번째 방법은 **도커 사설 레지스트리(Docker Private Registry)** 를 사용하는 것으로서 사용자가 직접 이미지 저장소를 만들 수 있습니다. 그러나 사용자가 직접 이미지 저장소 및 사용되는 서버, 저장 공간 등을 관리해야 하므로 도커 허브보다는 사용법이 까다롭습니다. 
>그러나 **회사의 내부망과 같은 곳에서 이미지를 배포해야 한다면** 도커 사설 레지스트리가 더 좋은 방안이 될 수 있습니다. 

>[!NOTE]
>2가지 방법에 대한 설명은 나중에 추가 예정

