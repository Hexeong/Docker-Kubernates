> [!info]
> 모든 컨테이너는 이미지를 기반으로 생성되므로 이미지를 다루는 방법은 도커 관리에서 빼놓을 수 없는 부분입니다. 이미지의 이름을 구성하는 저장소, 이미지 이름, 태그를 잘 관리하는 것 뿐만 아니라 이미지가 어떻게 생성되고 삭제되는지, 이미지의 구조는 어떻게 돼 있는지 등을 아는 것 또한 중요합니다. 이번 장에서는 이미지를 관리하는 기본적인 방법을 살펴보겠습니다.

> 도커는 기본적으로 `도커 허브(Docker Hub)`라는 `중앙 이미지 저장소`에서 이미지를 내려받습니다. 도커 허브는 도커가 공식적으로 제공하고 있는 이미지 저장소로서, 도커 계정을 갖고 있다면 `누구든지` 이미지를 올리고 내려받을 수 있기 때문에 다른 사람들에게 이미지를 쉽게 공유할 수 있습니다.

>[!important]
>단, 도커 허브는 누구나 이미지를 올릴 수 있기 때문에 공식(Official) 라벨이 없는 이미지는 사용법을 찾을 수 없거나 제대로 동작하지 않을 수 있습니다.
>또한 이미지 저장소를 다른 사람들에게 공개하지 않기 위해 비공개(Private) 저장소를 사용하려면 비공개 저장소의 수에 따라 요금을 지불해야 합니다. 
>이를 해결하기 위해 도커 이미지 저장소를 직접 구축해 비공개로 사용할 수도 있다는 점을 알아두시면 좋겠습니다.

>[!tip]
>도커 허브에 어떤 이미지가 있는지 확인하기 위해 도커 허브 사이트를 직접 접속해서 찾아볼 수 있지만, 도커 엔진에서 docker search 명령어를 사용할 수도 있습니다.

>[!tip]
>docker search 명령어는 도커 허브에서 이미지를 검색하며, 도커 허브 이미지임을 명시하기 위해 docker.io/ubuntu와 같이 docker.io 접두어를 사용할 수도 있습니다. 이는 다른 이미지 저장소와 구분하기 위함입니다.

# 2.3.1 도커 이미지 생성

>[!info]
>앞에서처럼 `docker search`를 통해 검색한 이미지를 pull 명령어로 내려받아 사용할 수도 있지만 도커로 개발하는 많은 경우에는 컨테이너에 애플리케이션을 위한 특정 개발 환경을 직접 구축한 뒤 사용자만의 이미지를 직접 생성해야 할 것입니다. 이를 위해 컨테이너 안에서 작업한 내용을 이미지로 만드는 방법을 먼저 설명하겠습니다.

```docker
다음 명령어를 입력해 이미지로 만들 컨테이너를 생성합니다. 컨테이너 내부에 first라는 이름의 파일을 하나 생성해 기존의 이미지로부터 변경하상을 만듭니다.

# docker run -i -t --name commit_test ubuntu:14.04
root@09a6f0f4cb0d:/# echo test_first >> first

first라는 파일을 만들어 ubuntu:14.04 이미지로부터 변경 사항을 만들었다면 컨테이너에서 호스트로 빠져나와 docker commit 명령어를 입력해 컨테이너를 이미지로 만듭니다. docker commit 명령어의 형식은 아래와 같습니다. 먼저 commit의 옵션을 지정하고 커밋할 컨테이너의 이름을 명시한 뒤 생성될 이미지의 이름을 입력합니다.

# docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]

다음 명령은 commit_test라는 컨테이너를 commit_test:first라는 이름의 이미지로 생성합니다.

# docker commit \
-a "Hexeong" -m "my first commit" \
commit_test \
commit_test:first

-a 옵션은 author를 뜻하며, 이미지의 작성자를 나타내는 메타데이터를 이미지에 포함시킵니다.
-m 옵션은 커밋 메세지를 뜻하며, 이미지에 포함될 부가 설명을 입력합니다.
```

# 2.3.2 이미지 구조 이해

>[!info]
>위와 같이 컨테이너를 이미지로 만드는 작업은 commit 명령어로 쉽게 수행할 수 있습니다. 그러나 이미지를 좀 더 효율적으로 다루기 위해 컨테이너가 어떻게 이미지로 만들어지며, 이미지의 구조는 어떻게 돼 있는지 알 필요가 있습니다. 다음 명령어를 입력해 이미지의 좀 더 자세한 정보를 확인해봅시다.

>[!tip]
>inspect 명령어는 컨테이너뿐만 아니라 네트워크, 볼륨, 이미지 등 모든 도커 단위의 정보를 얻을 때 사용할 수 있습니다. 단, 이름이 중복될 경우 컨테이너에 대해 먼저 수행되므로 --type을 명시하는 것이 좋습니다.

```docker
# docker inspect ubuntu:14.04
# docker inspect commit_test:first
# docker inspect commit_test:second

여기서 주의 깊게 볼 정보는 아랫부분에 위치한 Layers 항목입니다. ubuntu:14.04, commit_test:first, commit_test:second에 대한 각 Layers 항목은 다음과 같습니다. 16진수 해시 값 중 뒷부분을 생략했으며 ID 값은 아래 이미지와 다를 수 있습니다. 다음 그림은 각 이미지에 대한 inspect 명령어의 출력 결과 중 Layers 항목만 나타낸 것입니다.
```

![그림 2.36 ~ 그림 2.37](https://blog.kakaocdn.net/dn/Qy3mG/btq90lHWD2M/FKFMF5hSFgF8Sv76j00nT1/img.png)

> docker images에서 위 3개의 이미지 크기가 각각 188MB라고 출력돼도 188MB 크기의 이미지가 3개 존재하는 것은 아닙니다. 이미지를 커밋할 때 컨테이너에서 변경된 사항만 새로운 레이어로 저장하고, 그 레이어를 포함해 새로운 이미지를 생성하기 때문에 전체 이미지의 실제 크기는 188MB + first 파일의 크기 + second 파일의 크기가 됩니다.

>[!tip]
>이러한 이미지의 레이어 구조는 docker history 명령어를 통해 좀 더 쉽게 확인할 수 있습니다.

> 이번에는 생성한 이미지를 삭제해봅시다.

```docker
# docker rmi commit_test:first

이미지를 삭제할 경우 해당 이미지를 사용중인 컨테이너가 존재할 경우 삭제할 수 없습니다. 물론 -f 옵션을 추가해 이미지를 강제 삭제할 수 있지만 실제로 삭제하지 않고 이미지 이름만 삭제하기 때문에 의미가 없습니다. 이러한 이미지를 댕글링(dangling) 이미지라고 합니다. 댕글링 이미지는 아래 명령어로 별도로 확인 가능합니다.

# docker images -f dangling=true
```

>[!note]
>이처럼 레이어에 대한 개념을 생각하면서 이미지를 관리하면 효율적인 관리가 가능해집니다.

